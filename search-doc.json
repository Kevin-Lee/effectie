[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" Effectie","type":1,"pageTitle":"Getting Started","url":"docs/#effectie-logo-effectie","content":" Project\tBintray\tMaven Centraleffectie-cats-effect effectie-scalaz-effect  Supported Scala Versions: 2.11, 2.12, 2.13 and 3.0.0-M1 A set of type-classes and utils for functional effect libraries (i.e. Scalaz and Cats Effect). Why Effectie? Please read \"Why?\" section. "},{"title":"Getting Started","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"For Cats Effect","type":1,"pageTitle":"Getting Started","url":"docs/#for-cats-effect","content":"In build.sbt, Copy libraryDependencies += \"io.kevinlee\" %% \"effectie-cats-effect\" % \"1.6.0\" then import Copy import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ For more details, check out Effectie for Cats Effect. "},{"title":"For Scalaz Effect","type":1,"pageTitle":"Getting Started","url":"docs/#for-scalaz-effect","content":"In build.sbt, Copy libraryDependencies += \"io.kevinlee\" %% \"effectie-scalaz-effect\" % \"1.6.0\" then import Copy import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ For more details, check out Effectie for Scalaz Effect. "},{"title":"Why?","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"Tagless final gives us power to defer the decision of the implementations of contexts we're binding and functional effect libraries like Cats Effect and Scalaz Effect give us referential transparency. There might be an issue though with constructing an effect type data. It is actually an issue with Cats Effect as Cats Effect IO's pure (or Monad.pure) is not referentially transparent. Let's check out some code examples. e.g.) Cats Effect Copy import cats.effect._ // or cats.Monad[IO].pure(println(\"a\")) val io = IO.pure(println(\"a\")) // a // io: IO[Unit] = Pure(a = ()) // It is not referentially transparent so immediately evaluates println(\"a\") io.unsafeRunSync() io.unsafeRunSync() e.g.) Scalaz Effect Copy import scalaz._, scalaz.effect._ val io = Monad[IO].pure(println(\"a\")) // io: IO[Unit] = scalaz.effect.IO$$anon$7@2f4bc306 // It is referentially transparent so println(\"a\") is not evaluated here. io.unsafePerformIO() // a io.unsafePerformIO() // a So to have referential transparency when using Cats Effect, IO.apply() should be used. Copy import cats.effect._ val io = IO(println(\"a\")) // io: IO[Unit] = Delay(thunk = <function0>) // Now it is referentially transparent so println(\"a\") is not evaluated here. io.unsafeRunSync() // a io.unsafeRunSync() // a Now, let's use Cats Effect with tagless final. Copy import cats.effect._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]] extends Foo[F] { def get[A](a: => A): F[A] = // How would you construct F[A]? } // call-site val bar = new Bar[IO] bar.get(1) bar.get(println(\"a\")) How would you construct F[A]? You could probably do Applicative[F].pure or Monad[F].pure(a). Copy import cats._ class Bar[F[_]: Applicative] extends Foo[F] { // or [F[_]: Monad] def get[A](a: => A): F[A] = Applicative[F].pure(a) // or Monad[F].pure(a) } However, neither Applicative.pure nor Monad.pure in Cats are referentially transparent when it's mixed with impure code (e.g. some side-effect code like println(\"a\")). So If you do this, Copy val bar = new Bar[IO] val iou = bar.get(println(\"a\")) // a is printed here // and you get IO[Unit] iou.unsafeRunSync() // This does not print anything but returns () With Effectie you can do this. Copy import cats.effect._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: EffectConstructor] extends Foo[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App9$Bar@5c9a153a val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Or a more convenient way like Copy import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: EffectConstructor] extends Foo[F] { def get[A](a: => A): F[A] = effectOf(a) // no more EffectConstructor[F].effectOf } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App12$Bar@58e22a63 val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Check out Effectie for Cats EffectEffectie for Scalaz Effect "},{"title":"CanHandleError - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/can-handle-error","content":"","keywords":""},{"title":"CanHandleError","type":1,"pageTitle":"CanHandleError - Cats","url":"docs/cats-effect/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatalThrowable and to recover from it. It looks like this. Copy trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA >: A]( fa: => F[A] )( handleError: Throwable => F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA >: A]( fa: => F[A] )( handleError: Throwable => AA ): F[AA] def handleEitherTNonFatal[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => Either[AA, BB] ): EitherT[F, AA, BB] } There are instances available for cats.effect.IO, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal","type":1,"pageTitle":"CanHandleError - Cats","url":"docs/cats-effect/can-handle-error#canhandleerrorhandlenonfatal","content":"Copy import cats._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: EffectConstructor: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } println(bar[IO](1).unsafeRunSync()) // 1 println(bar[IO](-1).unsafeRunSync()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0 Copy import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: EffectConstructor: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0 "},{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"docs/cats-effect/cats-effect","content":"","keywords":""},{"title":"Effectie for Cats Effect","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#effectie-for-cats-effect","content":"EffectConstructorConsoleEffectCanCatchOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#all-in-one-example","content":"Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".asRight[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).value } } println(Something[IO].foo(1).unsafeRunSync()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafeRunSync()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[IO].bar(none[String]).unsafeRunSync()) // None println(Something[IO].baz(2.asRight[String]).unsafeRunSync()) // b: 2 / BLAH: blah blah // x: 4 // Right(4) println(Something[IO].baz(\"ERROR!!!\".asLeft[Int]).unsafeRunSync()) // Left(ERROR!!!) "},{"title":"ConsoleEffect - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect - Cats","url":"docs/cats-effect/console-effect#consoleeffect","content":"Copy import cats._ import cats.implicits._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect - Cats","url":"docs/cats-effect/console-effect#consoleeffectful","content":"Copy import cats._ import cats.implicits._ import effectie.cats.ConsoleEffectful._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"EffectConstructor - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor - Cats","url":"docs/cats-effect/effect-constructor#effectconstructor","content":"If you use Cats Effect and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. Copy import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res1: Int = 1 If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor - Cats","url":"docs/cats-effect/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. Copy import effectie.cats.Effectful._ import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res3: Int = 1 "},{"title":"EitherTSupport - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport - Cats","url":"docs/cats-effect/eithert-support#eithertsupport","content":"Copy import cats._ import cats.implicits._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x <- eitherTRightPure(a) // == EitherT.liftF(pureOf(a)) y <- eitherTRight(x + 10) // == EitherT.liftF(effectOf(x + 10)) y2 <- if (y > 100) eitherTLeft(\"Error - Bigger than 100\") else eitherTRightPure(y) // ↑ if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: Either[String, Int])) y <- eitherTOf((x + 999).asRight[String]) // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Either[String, Int] = Right(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Either[String, Int] = Right(value = 120) Something[IO].bar(1.asRight[String]).unsafeRunSync() // res3: Either[String, Int] = Right(value = 1000) Something[IO].bar(\"No number\".asLeft[Int]).unsafeRunSync() // res4: Either[String, Int] = Left(value = \"No number\") "},{"title":"CanCatch - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. Copy trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: => F[Either[A, B]])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatalThrowable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use","content":"IOFutureId Copy import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11126/0x000000010329c840@3a21e860, // index = 0 // ) fa.unsafeRunSync() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = 101), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11126/0x000000010329c840@893e14f, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = -1), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11126/0x000000010329c840@2a6c0a, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatalThrowable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-1","content":"IOFutureId Copy import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11146/0x0000000103330040@4ed1b596, // index = 1 // ) fa.unsafeRunSync() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-1","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = 100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@3c37b420, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-1","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = -100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@7c71d26b, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatalThrowable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-2","content":"IOFutureId Copy import cats.data.EitherT import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11146/0x0000000103330040@51a3ff52, // index = 1 // ) // ) fa.value.unsafeRunSync() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-2","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11149/0x0000000103336840@58a78fd // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@5c2bb504, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-2","content":"IOFutureId Copy import cats._ import cats.data.EitherT import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.EitherTSupport._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11149/0x0000000103336840@45fcac28 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@5464cc3e, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatalThrowable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-3","content":"IOFutureId Copy import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11126/0x000000010329c840@7610e9ea, // index = 0 // ) fa.unsafeRunSync() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-3","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = 101), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11126/0x000000010329c840@613278f7, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-3","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = -1), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11126/0x000000010329c840@691d6fd2, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatalThrowable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-4","content":"IOFutureId Copy import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11146/0x0000000103330040@51832bfe, // index = 1 // ) fa.unsafeRunSync() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-4","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = 100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@7192509a, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-4","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = -100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@54808f2f, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatalThrowable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-5","content":"IOFutureId Copy import cats.data.EitherT import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11146/0x0000000103330040@1faf2268, // index = 1 // ) // ) fa.value.unsafeRunSync() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-5","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11149/0x0000000103336840@12fbcda4 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@7fd3aa28, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-5","content":"IOFutureId Copy import cats._ import cats.data.EitherT import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11149/0x0000000103336840@1f402f10 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11146/0x0000000103330040@4ab4f26e, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"OptionTSupport - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport - Cats","url":"docs/cats-effect/optiont-support#optiontsupport","content":"Copy import cats._ import cats.implicits._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafeRunSync() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafeRunSync() // res4: Option[Int] = None "},{"title":"ConsoleEffect - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect - Scalaz","url":"docs/scalaz-effect/console-effect#consoleeffect","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect - Scalaz","url":"docs/scalaz-effect/console-effect#consoleeffectful","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"EffectConstructor - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor - Scalaz","url":"docs/scalaz-effect/effect-constructor#effectconstructor","content":"If you use Scalaz Effect and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. Copy import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@4b75098a get1.unsafePerformIO() // res1: Int = 1 If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor - Scalaz","url":"docs/scalaz-effect/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. Copy import effectie.scalaz.Effectful._ import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@5a733c93 get1.unsafePerformIO() // res3: Int = 1 "},{"title":"EitherTSupport - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport - Scalaz","url":"docs/scalaz-effect/eithert-support#eithertsupport","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[String \\/ Int] def bar(a: String \\/ Int): F[String \\/ Int] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[String \\/ Int] = (for { x <- eitherTRightPure(a) // == EitherT(pureOf(a).map(_.right[String])) y <- eitherTRight(x + 10) // == EitherT(effectOf(x + 10).map(_.right[String])) y2 <- if (y > 100) eitherTLeft[Int](\"Error - Bigger than 100\") else eitherTRightPure[String](y) // ↑ if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.left[Int])) // else // EitherT(pureOf(y).map(_.right[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT(effectOf(y + 100).map(_.right)) } yield z).run def bar(a: String \\/ Int): F[String \\/ Int] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: String \\/ Int)) y <- eitherTOf((x + 999).right[String]) // == EitherT(effectOf((x + 999).right[String])) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: String \\/ Int = \\/-(b = 111) Something[IO].foo(10).unsafePerformIO() // res2: String \\/ Int = \\/-(b = 120) Something[IO].bar(1.right[String]).unsafePerformIO() // res3: String \\/ Int = \\/-(b = 1000) Something[IO].bar(\"No number\".left[Int]).unsafePerformIO() // res4: String \\/ Int = -\\/(a = \"No number\") "},{"title":"OptionTSupport - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport - Scalaz","url":"docs/scalaz-effect/optiont-support#optiontsupport","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).run def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafePerformIO() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafePerformIO() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafePerformIO() // res4: Option[Int] = None "},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/scalaz-effect","content":"","keywords":""},{"title":"Effectie for Scalaz Effect","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#effectie-for-scalaz-effect","content":"EffectConstructorConsoleEffectOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#all-in-one-example","content":"Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: A \\/ B): F[A \\/ B] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).run override def baz[A, B: Semigroup](ab: A \\/ B): F[A \\/ B] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".right[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).run } } println(Something[IO].foo(1).unsafePerformIO()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafePerformIO()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[IO].bar(none[String]).unsafePerformIO()) // None println(Something[IO].baz(2.right[String]).unsafePerformIO()) // b: 2 / BLAH: blah blah // x: 4 // \\/-(4) println(Something[IO].baz(\"ERROR!!!\".left[Int]).unsafePerformIO()) // -\\/(ERROR!!!) "},{"title":"CanCatch - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. Copy trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEither[A, B](fab: => F[A \\/ B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatalThrowable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use","content":"IOFutureId Copy import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[scalaz.\\/[Throwable, Nothing]] = scalaz.effect.IO$$anon$7@4e0938a9 fa.unsafePerformIO() // res1: scalaz.\\/[Throwable, Nothing] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@72f3d230 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@21f69c79 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatalThrowable from F[A \\/ B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-1","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@205024af fa.unsafePerformIO() // res19: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-1","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@7dc20746 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-1","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@4547ece5 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatalThrowable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-2","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@5e1876ed // ) fa.run.unsafePerformIO() // res37: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-2","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6c7b1459 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-2","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@67b6ff77 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatalThrowable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-3","content":"IOFutureId Copy import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatal( IO((throw new RuntimeException(\"Something's wrong!\")): Int) )(identity) // fa: IO[scalaz.\\/[Throwable, Int]] = scalaz.effect.IO$$anon$7@4f3d065b fa.unsafePerformIO() // res55: scalaz.\\/[Throwable, Int] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-3","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6c95a2ea val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-3","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@78423d30 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatalThrowable from F[A \\/ B] and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-4","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@4b85cf4b fa.unsafePerformIO() // res73: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-4","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@744a2c89 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-4","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@1ae75d3f val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatalThrowable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-5","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@1a893b8b // ) fa.run.unsafePerformIO() // res91: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-5","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@11322f55 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-5","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@47da0d76 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "}]