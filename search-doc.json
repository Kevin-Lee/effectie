[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" Effectie","type":1,"pageTitle":"Getting Started","url":"docs/#effectie-logo-effectie","content":" Project\tBintray\tMaven Centraleffectie-cats-effect effectie-scalaz-effect  Supported Scala Versions: 2.11, 2.12, 2.13 and 3.0.0-M1 A set of type-classes and utils for functional effect libraries (i.e. Scalaz and Cats Effect). Why Effectie? Please read \"Why?\" section. "},{"title":"Getting Started","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"For Cats Effect","type":1,"pageTitle":"Getting Started","url":"docs/#for-cats-effect","content":"In build.sbt, Copy libraryDependencies += \"io.kevinlee\" %% \"effectie-cats-effect\" % \"1.5.0\" then import Copy import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ For more details, check out Effectie for Cats Effect. "},{"title":"For Scalaz Effect","type":1,"pageTitle":"Getting Started","url":"docs/#for-scalaz-effect","content":"In build.sbt, Copy libraryDependencies += \"io.kevinlee\" %% \"effectie-scalaz-effect\" % \"1.5.0\" then import Copy import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ For more details, check out Effectie for Scalaz Effect. "},{"title":"Why?","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"Tagless final gives us power to defer the decision of the implementations of contexts we're binding and functional effect libraries like Cats Effect and Scalaz Effect give us referential transparency. There might be an issue though with constructing an effect type data. It is actually an issue with Cats Effect as Cats Effect IO's pure (or Monad.pure) is not referentially transparent. Let's check out some code examples. e.g.) Cats Effect Copy import cats.effect._ // or cats.Monad[IO].pure(println(\"a\")) val io = IO.pure(println(\"a\")) // a // io: IO[Unit] = Pure(a = ()) // It is not referentially transparent so immediately evaluates println(\"a\") io.unsafeRunSync() io.unsafeRunSync() e.g.) Scalaz Effect Copy import scalaz._, scalaz.effect._ val io = Monad[IO].pure(println(\"a\")) // io: IO[Unit] = scalaz.effect.IO$$anon$7@53a0d9aa // It is referentially transparent so println(\"a\") is not evaluated here. io.unsafePerformIO() // a io.unsafePerformIO() // a So to have referential transparency when using Cats Effect, IO.apply() should be used. Copy import cats.effect._ val io = IO(println(\"a\")) // io: IO[Unit] = Delay(thunk = <function0>) // Now it is referentially transparent so println(\"a\") is not evaluated here. io.unsafeRunSync() // a io.unsafeRunSync() // a Now, let's use Cats Effect with tagless final. Copy import cats.effect._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]] extends Foo[F] { def get[A](a: => A): F[A] = // How would you construct F[A]? } // call-site val bar = new Bar[IO] bar.get(1) bar.get(println(\"a\")) How would you construct F[A]? You could probably do Applicative[F].pure or Monad[F].pure(a). Copy import cats._ class Bar[F[_]: Applicative] extends Foo[F] { // or [F[_]: Monad] def get[A](a: => A): F[A] = Applicative[F].pure(a) // or Monad[F].pure(a) } However, neither Applicative.pure nor Monad.pure in Cats are referentially transparent when it's mixed with impure code (e.g. some side-effect code like println(\"a\")). So If you do this, Copy val bar = new Bar[IO] val iou = bar.get(println(\"a\")) // a is printed here // and you get IO[Unit] iou.unsafeRunSync() // This does not print anything but returns () With Effectie you can do this. Copy import cats.effect._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: EffectConstructor] extends Foo[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App9$Bar@21683a87 val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Or a more convenient way like Copy import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: EffectConstructor] extends Foo[F] { def get[A](a: => A): F[A] = effectOf(a) // no more EffectConstructor[F].effectOf } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App12$Bar@4d1f6f07 val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Check out Effectie for Cats EffectEffectie for Scalaz Effect "},{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"docs/cats-effect/cats-effect","content":"","keywords":""},{"title":"Effectie for Cats Effect","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#effectie-for-cats-effect","content":"EffectConstructorConsoleEffectCanCatchOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#all-in-one-example","content":"Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".asRight[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).value } } println(Something[IO].foo(1).unsafeRunSync()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafeRunSync()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[IO].bar(none[String]).unsafeRunSync()) // None println(Something[IO].baz(2.asRight[String]).unsafeRunSync()) // b: 2 / BLAH: blah blah // x: 4 // Right(4) println(Something[IO].baz(\"ERROR!!!\".asLeft[Int]).unsafeRunSync()) // Left(ERROR!!!) "},{"title":"ConsoleEffect - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect - Cats","url":"docs/cats-effect/console-effect#consoleeffect","content":"Copy import cats._ import cats.implicits._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect - Cats","url":"docs/cats-effect/console-effect#consoleeffectful","content":"Copy import cats._ import cats.implicits._ import effectie.cats.ConsoleEffectful._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"CanCatch - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. Copy trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: => F[Either[A, B]])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatalThrowable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use","content":"IOFutureId Copy import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11086/0x00000001031c8040@45282161, // index = 0 // ) fa.unsafeRunSync() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = 101), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11086/0x00000001031c8040@b93332e, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = -1), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11086/0x00000001031c8040@3b87e7d, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatalThrowable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-1","content":"IOFutureId Copy import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11106/0x0000000103253840@b281dd8, // index = 1 // ) fa.unsafeRunSync() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-1","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = 100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@70e93102, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-1","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = -100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@5da7310a, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatalThrowable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-2","content":"IOFutureId Copy import cats.data.EitherT import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11106/0x0000000103253840@3f304525, // index = 1 // ) // ) fa.value.unsafeRunSync() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-2","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11109/0x0000000103256840@29ebfea1 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@52d8ac81, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-2","content":"IOFutureId Copy import cats._ import cats.data.EitherT import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.EitherTSupport._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11109/0x0000000103256840@7e16ad8 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@30611876, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatalThrowable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-3","content":"IOFutureId Copy import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11086/0x00000001031c8040@2ae0ce7a, // index = 0 // ) fa.unsafeRunSync() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-3","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = 101), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11086/0x00000001031c8040@1b4c8367, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-3","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = -1), f = <function1>), // f = <function1> // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$11086/0x00000001031c8040@791945e5, // index = 0 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatalThrowable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-4","content":"IOFutureId Copy import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11106/0x0000000103253840@359620f, // index = 1 // ) fa.unsafeRunSync() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-4","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = 100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@342b32e7, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-4","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind(source = Pure(a = Right(value = -100)), f = <function1>), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@2c5865a9, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatalThrowable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#how-to-use-5","content":"IOFutureId Copy import cats.data.EitherT import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Bind(source = Delay(thunk = <function0>), f = <function1>), // f = scala.Function1$$Lambda$11106/0x0000000103253840@38658a81, // index = 1 // ) // ) fa.value.unsafeRunSync() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#happy-path-example-5","content":"IOFutureId Copy import cats._ import cats.implicits._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11109/0x0000000103256840@1a885368 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@1250e380, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Cats","url":"docs/cats-effect/can-catch#unhappy-path-example-5","content":"IOFutureId Copy import cats._ import cats.data.EitherT import cats.implicits._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11109/0x0000000103256840@5db4cd98 // ), // f = <function1> // ), // f = scala.Function1$$Lambda$11106/0x0000000103253840@760fa3ee, // index = 1 // ) val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"EffectConstructor - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor - Cats","url":"docs/cats-effect/effect-constructor#effectconstructor","content":"If you use Cats Effect and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. Copy import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res1: Int = 1 If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor - Cats","url":"docs/cats-effect/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. Copy import effectie.cats.Effectful._ import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res3: Int = 1 "},{"title":"EitherTSupport - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport - Cats","url":"docs/cats-effect/eithert-support#eithertsupport","content":"Copy import cats._ import cats.implicits._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x <- eitherTRightPure(a) // == EitherT.liftF(pureOf(a)) y <- eitherTRight(x + 10) // == EitherT.liftF(effectOf(x + 10)) y2 <- if (y > 100) eitherTLeft(\"Error - Bigger than 100\") else eitherTRightPure(y) // ↑ if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: Either[String, Int])) y <- eitherTOf((x + 999).asRight[String]) // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Either[String, Int] = Right(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Either[String, Int] = Right(value = 120) Something[IO].bar(1.asRight[String]).unsafeRunSync() // res3: Either[String, Int] = Right(value = 1000) Something[IO].bar(\"No number\".asLeft[Int]).unsafeRunSync() // res4: Either[String, Int] = Left(value = \"No number\") "},{"title":"OptionTSupport - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport - Cats","url":"docs/cats-effect/optiont-support#optiontsupport","content":"Copy import cats._ import cats.implicits._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafeRunSync() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafeRunSync() // res4: Option[Int] = None "},{"title":"ConsoleEffect - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect - Scalaz","url":"docs/scalaz-effect/console-effect#consoleeffect","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect - Scalaz","url":"docs/scalaz-effect/console-effect#consoleeffectful","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done "},{"title":"EffectConstructor - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor - Scalaz","url":"docs/scalaz-effect/effect-constructor#effectconstructor","content":"If you use Scalaz Effect and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. Copy import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@6e0b3395 get1.unsafePerformIO() // res1: Int = 1 If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor - Scalaz","url":"docs/scalaz-effect/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. Copy import effectie.scalaz.Effectful._ import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@34d2f125 get1.unsafePerformIO() // res3: Int = 1 "},{"title":"EitherTSupport - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport - Scalaz","url":"docs/scalaz-effect/eithert-support#eithertsupport","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[String \\/ Int] def bar(a: String \\/ Int): F[String \\/ Int] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[String \\/ Int] = (for { x <- eitherTRightPure(a) // == EitherT(pureOf(a).map(_.right[String])) y <- eitherTRight(x + 10) // == EitherT(effectOf(x + 10).map(_.right[String])) y2 <- if (y > 100) eitherTLeft[Int](\"Error - Bigger than 100\") else eitherTRightPure[String](y) // ↑ if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.left[Int])) // else // EitherT(pureOf(y).map(_.right[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT(effectOf(y + 100).map(_.right)) } yield z).run def bar(a: String \\/ Int): F[String \\/ Int] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: String \\/ Int)) y <- eitherTOf((x + 999).right[String]) // == EitherT(effectOf((x + 999).right[String])) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: String \\/ Int = \\/-(b = 111) Something[IO].foo(10).unsafePerformIO() // res2: String \\/ Int = \\/-(b = 120) Something[IO].bar(1.right[String]).unsafePerformIO() // res3: String \\/ Int = \\/-(b = 1000) Something[IO].bar(\"No number\".left[Int]).unsafePerformIO() // res4: String \\/ Int = -\\/(a = \"No number\") "},{"title":"OptionTSupport - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport - Scalaz","url":"docs/scalaz-effect/optiont-support#optiontsupport","content":"Copy import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).run def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafePerformIO() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafePerformIO() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafePerformIO() // res4: Option[Int] = None "},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/scalaz-effect","content":"","keywords":""},{"title":"Effectie for Scalaz Effect","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#effectie-for-scalaz-effect","content":"EffectConstructorConsoleEffectOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#all-in-one-example","content":"Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: A \\/ B): F[A \\/ B] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).run override def baz[A, B: Semigroup](ab: A \\/ B): F[A \\/ B] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".right[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).run } } println(Something[IO].foo(1).unsafePerformIO()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafePerformIO()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[IO].bar(none[String]).unsafePerformIO()) // None println(Something[IO].baz(2.right[String]).unsafePerformIO()) // b: 2 / BLAH: blah blah // x: 4 // \\/-(4) println(Something[IO].baz(\"ERROR!!!\".left[Int]).unsafePerformIO()) // -\\/(ERROR!!!) "},{"title":"CanCatch - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. Copy trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEither[A, B](fab: => F[A \\/ B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatalThrowable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use","content":"IOFutureId Copy import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[scalaz.\\/[Throwable, Nothing]] = scalaz.effect.IO$$anon$7@15ee319f fa.unsafePerformIO() // res1: scalaz.\\/[Throwable, Nothing] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@534ef9a6 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@26ac7632 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatalThrowable from F[A \\/ B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-1","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@626c2597 fa.unsafePerformIO() // res19: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-1","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@504be8f2 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-1","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@298fb93 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatalThrowable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-2","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@1bc57080 // ) fa.run.unsafePerformIO() // res37: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-2","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@500105ac val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-2","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@5101651b val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatalThrowable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatalThrowable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-3","content":"IOFutureId Copy import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatal( IO((throw new RuntimeException(\"Something's wrong!\")): Int) )(identity) // fa: IO[scalaz.\\/[Throwable, Int]] = scalaz.effect.IO$$anon$7@76fae044 fa.unsafePerformIO() // res55: scalaz.\\/[Throwable, Int] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-3","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@3a47e4aa val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-3","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@591336bc val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatalThrowable from F[A \\/ B] and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-4","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@59ee88f7 fa.unsafePerformIO() // res73: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-4","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6f99bd50 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-4","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@4f425a34 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatalThrowable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#how-to-use-5","content":"IOFutureId Copy import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@28ce59a5 // ) fa.run.unsafePerformIO() // res91: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#happy-path-example-5","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6d7ec6fd val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch - Scalaz","url":"docs/scalaz-effect/can-catch#unhappy-path-example-5","content":"IOFutureId Copy import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@1d8f2330 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) "}]