[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" Effectie","type":1,"pageTitle":"Getting Started","url":"docs/#effectie-logo-effectie","content":" Project\tMaven Centraleffectie-cats-effect effectie-monix effectie-scalaz-effect\t Supported Scala Versions: 2.11.12, 2.12.13, 2.13.5, 3.0.0-RC1, 3.0.0-RC2 and 3.0.0-RC3 A set of type-classes and utils for functional effect libraries (i.e. Scalaz and Cats Effect). Why Effectie? Please read \"Why?\" section. "},{"title":"Getting Started","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"For Cats Effect","type":1,"pageTitle":"Getting Started","url":"docs/#for-cats-effect","content":"In build.sbt, libraryDependencies += \"io.kevinlee\" %% \"effectie-cats-effect\" % \"1.10.0\" Copy then import import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ Copy For more details, check out Effectie for Cats Effect. "},{"title":"For Monix","type":1,"pageTitle":"Getting Started","url":"docs/#for-monix","content":"In build.sbt, libraryDependencies += \"io.kevinlee\" %% \"effectie-monix\" % \"1.10.0\" Copy then import import effectie.monix.ConsoleEffectful._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ import effectie.monix.OptionTSupport._ import effectie.monix._ Copy For more details, check out Effectie for Monix. "},{"title":"For Scalaz Effect","type":1,"pageTitle":"Getting Started","url":"docs/#for-scalaz-effect","content":"In build.sbt, libraryDependencies += \"io.kevinlee\" %% \"effectie-scalaz-effect\" % \"1.10.0\" Copy then import import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ Copy For more details, check out Effectie for Scalaz Effect. "},{"title":"Why?","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"Tagless final gives us power to defer the decision of the implementations of contexts we're binding and functional effect libraries like Cats Effect and Scalaz Effect give us referential transparency. There might be an issue though with constructing an effect type data. It is actually an issue with Cats Effect as Cats Effect IO's pure (or Monad.pure) is not referentially transparent. Let's check out some code examples. e.g.) Cats Effect import cats.effect._ // or cats.Monad[IO].pure(println(\"a\")) val io = IO.pure(println(\"a\")) // a // io: IO[Unit] = Pure(a = ()) // It is not referentially transparent so immediately evaluates println(\"a\") io.unsafeRunSync() io.unsafeRunSync() Copy e.g.) Scalaz Effect import scalaz._, scalaz.effect._ val io = Monad[IO].pure(println(\"a\")) // io: IO[Unit] = scalaz.effect.IO$$anon$7@6243d34c // It is referentially transparent so println(\"a\") is not evaluated here. io.unsafePerformIO() // a io.unsafePerformIO() // a Copy So to have referential transparency when using Cats Effect, IO.apply() should be used. import cats.effect._ val io = IO(println(\"a\")) // io: IO[Unit] = Delay(thunk = <function0>) // Now it is referentially transparent so println(\"a\") is not evaluated here. io.unsafeRunSync() // a io.unsafeRunSync() // a Copy Now, let's use Cats Effect with tagless final. import cats.effect._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]] extends Foo[F] { def get[A](a: => A): F[A] = // How would you construct F[A]? } // call-site val bar = new Bar[IO] bar.get(1) bar.get(println(\"a\")) Copy How would you construct F[A]? You could probably do Applicative[F].pure or Monad[F].pure(a). import cats._ class Bar[F[_]: Applicative] extends Foo[F] { // or [F[_]: Monad] def get[A](a: => A): F[A] = Applicative[F].pure(a) // or Monad[F].pure(a) } Copy However, neither Applicative.pure nor Monad.pure in Cats are referentially transparent when it's mixed with impure code (e.g. some side-effect code like println(\"a\")). So If you do this, val bar = new Bar[IO] val iou = bar.get(println(\"a\")) // a is printed here // and you get IO[Unit] iou.unsafeRunSync() // This does not print anything but returns () Copy With Effectie you can do this. import cats.effect._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: EffectConstructor] extends Foo[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App9$Bar@21409334 val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Copy Or a more convenient way like import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: EffectConstructor] extends Foo[F] { def get[A](a: => A): F[A] = effectOf(a) // no more EffectConstructor[F].effectOf } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App12$Bar@24db1c2c val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Copy Check out Effectie for Cats EffectEffectie for Scalaz Effect "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"docs/cats-effect/can-handle-error","content":"","keywords":""},{"title":"CanHandleError","type":1,"pageTitle":"CanHandleError","url":"docs/cats-effect/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA >: A]( fa: => F[A] )( handleError: Throwable => F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA >: A]( fa: => F[A] )( handleError: Throwable => AA ): F[AA] def handleEitherTNonFatal[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => Either[AA, BB] ): EitherT[F, AA, BB] } Copy There are instances available for cats.effect.IO, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal","type":1,"pageTitle":"CanHandleError","url":"docs/cats-effect/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: EffectConstructor: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } println(bar[IO](1).unsafeRunSync()) // 1 println(bar[IO](-1).unsafeRunSync()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0 Copy import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: EffectConstructor: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0 Copy "},{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"docs/cats-effect/cats-effect","content":"","keywords":""},{"title":"Effectie for Cats Effect","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#effectie-for-cats-effect","content":"EffectConstructorConsoleEffectCanCatchCanHandleErrorFromFutureOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#all-in-one-example","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".asRight[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).value } } println(Something[IO].foo(1).unsafeRunSync()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafeRunSync()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[IO].bar(none[String]).unsafeRunSync()) // None println(Something[IO].baz(2.asRight[String]).unsafeRunSync()) // b: 2 / BLAH: blah blah // x: 4 // Right(4) println(Something[IO].baz(\"ERROR!!!\".asLeft[Int]).unsafeRunSync()) // Left(ERROR!!!) Copy "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"docs/cats-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect","url":"docs/cats-effect/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect","url":"docs/cats-effect/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.cats.ConsoleEffectful._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"EffectConstructor","type":0,"sectionRef":"#","url":"docs/cats-effect/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor","url":"docs/cats-effect/effect-constructor#effectconstructor","content":"If you use Cats Effect and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res1: Int = 1 Copy If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor","url":"docs/cats-effect/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.cats.Effectful._ import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res3: Int = 1 Copy "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"docs/cats-effect/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: => F[Either[A, B]])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } Copy "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use","content":"IOFutureId import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$10967/0x0000000102bd2840@15298e6b, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // mdoc.internal.cli.MainOps$.process(MainOps.scala:269), // mdoc.Main$.process(Main.scala:26), // mdoc.Main$.process(Main.scala:21), // mdoc.Main$.main(Main.scala:16), // ... fa.unsafeRunSync() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App6$$anonfun$doSomething$1.apply(can-catch.md:117), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App6$.doSomething(can-catch.md:120), // repl.MdocSession$App6$.<clinit>(can-catch.md:123), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App12$$anonfun$doSomething$7.apply(can-catch.md:317), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App12$.doSomething(can-catch.md:320), // repl.MdocSession$App12$.<clinit>(can-catch.md:323), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // repl.MdocSession$App8$.<clinit>(can-catch.md:217), // repl.MdocSession$App6$.<clinit>(can-catch.md:137), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-1","content":"IOFutureId import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$10967/0x0000000102bd2840@7780e113, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // ... fa.unsafeRunSync() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App24$$anonfun$doSomething$13.apply(can-catch.md:597), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App24$.doSomething(can-catch.md:600), // repl.MdocSession$App24$.<clinit>(can-catch.md:603), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // repl.MdocSession$App8$.<clinit>(can-catch.md:217), // repl.MdocSession$App6$.<clinit>(can-catch.md:137), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App30$$anonfun$doSomething$19.apply(can-catch.md:829), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App30$.doSomething(can-catch.md:832), // repl.MdocSession$App30$.<clinit>(can-catch.md:835), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // repl.MdocSession$App8$.<clinit>(can-catch.md:217), // repl.MdocSession$App6$.<clinit>(can-catch.md:137), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-2","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$10967/0x0000000102bd2840@2d692201, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // ... fa.value.unsafeRunSync() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-2","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@2d3f1cfd, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.cats.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:20), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.CanCatch.catchNonFatalEitherT(CanCatch.scala:20), // effectie.cats.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.cats.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-2","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.EitherTSupport._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@6a69c825, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.cats.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:20), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.CanCatch.catchNonFatalEitherT(CanCatch.scala:20), // effectie.cats.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.cats.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-3","content":"IOFutureId import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$10967/0x0000000102bd2840@6d5899d0, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // mdoc.internal.cli.MainOps$.process(MainOps.scala:269), // mdoc.Main$.process(Main.scala:26), // mdoc.Main$.process(Main.scala:21), // mdoc.Main$.main(Main.scala:16), // ... fa.unsafeRunSync() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App60$$anonfun$doSomething$37.apply(can-catch.md:1703), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App60$.doSomething(can-catch.md:1706), // repl.MdocSession$App60$.<clinit>(can-catch.md:1709), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // repl.MdocSession$App48$.<clinit>(can-catch.md:1418), // repl.MdocSession$App46$.<clinit>(can-catch.md:1338), // repl.MdocSession$App44$.<clinit>(can-catch.md:1264), // repl.MdocSession$App42$.<clinit>(can-catch.md:1168), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App66$$anonfun$doSomething$43.apply(can-catch.md:1913), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App66$.doSomething(can-catch.md:1916), // repl.MdocSession$App66$.<clinit>(can-catch.md:1919), // repl.MdocSession$App64$.<clinit>(can-catch.md:1867), // repl.MdocSession$App62$.<clinit>(can-catch.md:1807), // repl.MdocSession$App60$.<clinit>(can-catch.md:1723), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // repl.MdocSession$App48$.<clinit>(can-catch.md:1418), // repl.MdocSession$App46$.<clinit>(can-catch.md:1338), // repl.MdocSession$App44$.<clinit>(can-catch.md:1264), // repl.MdocSession$App42$.<clinit>(can-catch.md:1168), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-4","content":"IOFutureId import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$10967/0x0000000102bd2840@120e5474, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // ... fa.unsafeRunSync() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App78$$anonfun$doSomething$49.apply(can-catch.md:2202), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App78$.doSomething(can-catch.md:2205), // repl.MdocSession$App78$.<clinit>(can-catch.md:2208), // repl.MdocSession$App76$.<clinit>(can-catch.md:2145), // repl.MdocSession$App74$.<clinit>(can-catch.md:2128), // repl.MdocSession$App72$.<clinit>(can-catch.md:2096), // repl.MdocSession$App70$.<clinit>(can-catch.md:2076), // repl.MdocSession$App68$.<clinit>(can-catch.md:2016), // repl.MdocSession$App66$.<clinit>(can-catch.md:1933), // repl.MdocSession$App64$.<clinit>(can-catch.md:1867), // repl.MdocSession$App62$.<clinit>(can-catch.md:1807), // repl.MdocSession$App60$.<clinit>(can-catch.md:1723), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // repl.MdocSession$App48$.<clinit>(can-catch.md:1418), // repl.MdocSession$App46$.<clinit>(can-catch.md:1338), // repl.MdocSession$App44$.<clinit>(can-catch.md:1264), // repl.MdocSession$App42$.<clinit>(can-catch.md:1168), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App84$$anonfun$doSomething$55.apply(can-catch.md:2443), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App84$.doSomething(can-catch.md:2446), // repl.MdocSession$App84$.<clinit>(can-catch.md:2449), // repl.MdocSession$App82$.<clinit>(can-catch.md:2386), // repl.MdocSession$App80$.<clinit>(can-catch.md:2315), // repl.MdocSession$App78$.<clinit>(can-catch.md:2222), // repl.MdocSession$App76$.<clinit>(can-catch.md:2145), // repl.MdocSession$App74$.<clinit>(can-catch.md:2128), // repl.MdocSession$App72$.<clinit>(can-catch.md:2096), // repl.MdocSession$App70$.<clinit>(can-catch.md:2076), // repl.MdocSession$App68$.<clinit>(can-catch.md:2016), // repl.MdocSession$App66$.<clinit>(can-catch.md:1933), // repl.MdocSession$App64$.<clinit>(can-catch.md:1867), // repl.MdocSession$App62$.<clinit>(can-catch.md:1807), // repl.MdocSession$App60$.<clinit>(can-catch.md:1723), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // repl.MdocSession$App48$.<clinit>(can-catch.md:1418), // repl.MdocSession$App46$.<clinit>(can-catch.md:1338), // repl.MdocSession$App44$.<clinit>(can-catch.md:1264), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-5","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.cats.CanCatch$$anon$1$$Lambda$10967/0x0000000102bd2840@c50bd09, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // ... fa.value.unsafeRunSync() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-5","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@7ed0a1db, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.cats.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:20), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.CanCatch.catchNonFatalEitherT(CanCatch.scala:20), // effectie.cats.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.cats.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-5","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@61f2135b, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.cats.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:20), // effectie.cats.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:31), // effectie.cats.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.CanCatch.catchNonFatalEitherT(CanCatch.scala:20), // effectie.cats.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.cats.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"docs/cats-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport","url":"docs/cats-effect/eithert-support#eithertsupport","content":"import cats._ import cats.syntax.all._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x <- eitherTRightPure(a) // == EitherT.liftF(pureOf(a)) y <- eitherTRight(x + 10) // == EitherT.liftF(effectOf(x + 10)) y2 <- if (y > 100) eitherTLeft(\"Error - Bigger than 100\") else eitherTRightPure(y) //  if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: Either[String, Int])) y <- eitherTOf((x + 999).asRight[String]) // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Either[String, Int] = Right(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Either[String, Int] = Right(value = 120) Something[IO].bar(1.asRight[String]).unsafeRunSync() // res3: Either[String, Int] = Right(value = 1000) Something[IO].bar(\"No number\".asLeft[Int]).unsafeRunSync() // res4: Either[String, Int] = Left(value = \"No number\") Copy "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"docs/cats-effect/from-future","content":"","keywords":""},{"title":"FromFuture","type":1,"pageTitle":"FromFuture","url":"docs/cats-effect/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for cats.effect.IOFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: => Future[A]): F[A] } Copy "},{"title":"FromFuture.toEffect","type":1,"pageTitle":"FromFuture","url":"docs/cats-effect/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: EffectConstructor](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: EffectConstructor: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a <- FromFuture[F].toEffect(foo(n)) b <- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@3fece4ea[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 1, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@7b5a6f2c implicit val cs: ContextShift[IO] = IO.contextShift(ec) // cs: ContextShift[IO] = cats.effect.internals.IOContextShift@7233e3d try { println(MyApp.baz[IO](1).unsafeRunSync()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202 Copy "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"docs/cats-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport","url":"docs/cats-effect/optiont-support#optiontsupport","content":"import cats._ import cats.syntax.all._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafeRunSync() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafeRunSync() // res4: Option[Int] = None Copy "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"docs/monix/can-handle-error","content":"","keywords":""},{"title":"CanHandleError","type":1,"pageTitle":"CanHandleError","url":"docs/monix/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA >: A]( fa: => F[A] )( handleError: Throwable => F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA >: A]( fa: => F[A] )( handleError: Throwable => AA ): F[AA] def handleEitherTNonFatal[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => Either[AA, BB] ): EitherT[F, AA, BB] } Copy There are instances available for monix.eval.Task, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal","type":1,"pageTitle":"CanHandleError","url":"docs/monix/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: EffectConstructor: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } import monix.execution.Scheduler.Implicits.global println(bar[Task](1).runSyncUnsafe()) // 1 println(bar[Task](-1).runSyncUnsafe()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0 Copy import effectie.monix._ import effectie.monix.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: EffectConstructor: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0 Copy "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"docs/monix/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect","url":"docs/monix/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.monix._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val foo = Something[Task].foo() foo.runSyncUnsafe() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect","url":"docs/monix/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.monix.ConsoleEffectful._ import effectie.monix._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val foo = Something[Task].foo() foo.runSyncUnsafe() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"EffectConstructor","type":0,"sectionRef":"#","url":"docs/monix/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor","url":"docs/monix/effect-constructor#effectconstructor","content":"If you use Monix and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. import effectie.monix._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = <function0>) get1.runSyncUnsafe() // res1: Int = 1 Copy If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor","url":"docs/monix/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.monix.Effectful._ import effectie.monix._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = <function0>) get1.runSyncUnsafe() // res3: Int = 1 Copy "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"docs/monix/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport","url":"docs/monix/eithert-support#eithertsupport","content":"import cats._ import cats.syntax.all._ import effectie.monix.Effectful._ import effectie.monix._ import effectie.monix.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x <- eitherTRightPure(a) // == EitherT.liftF(pureOf(a)) y <- eitherTRight(x + 10) // == EitherT.liftF(effectOf(x + 10)) y2 <- if (y > 100) eitherTLeft(\"Error - Bigger than 100\") else eitherTRightPure(y) //  if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: Either[String, Int])) y <- eitherTOf((x + 999).asRight[String]) // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import monix.eval._ import monix.execution.Scheduler.Implicits.global Something[Task].foo(1).runSyncUnsafe() // res1: Either[String, Int] = Right(value = 111) Something[Task].foo(10).runSyncUnsafe() // res2: Either[String, Int] = Right(value = 120) Something[Task].bar(1.asRight[String]).runSyncUnsafe() // res3: Either[String, Int] = Right(value = 1000) Something[Task].bar(\"No number\".asLeft[Int]).runSyncUnsafe() // res4: Either[String, Int] = Left(value = \"No number\") Copy "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"docs/monix/from-future","content":"","keywords":""},{"title":"FromFuture","type":1,"pageTitle":"FromFuture","url":"docs/monix/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for monix.eval.TaskFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: => Future[A]): F[A] } Copy "},{"title":"FromFuture.toEffect","type":1,"pageTitle":"FromFuture","url":"docs/monix/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: EffectConstructor](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: EffectConstructor: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a <- FromFuture[F].toEffect(foo(n)) b <- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@4500eb5[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 0, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@283faad import monix.execution.Scheduler.Implicits.global try { println(MyApp.baz[Task](1).runSyncUnsafe()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202 Copy "},{"title":"For Monix","type":0,"sectionRef":"#","url":"docs/monix/monix","content":"","keywords":""},{"title":"Effectie for Monix","type":1,"pageTitle":"For Monix","url":"docs/monix/monix#effectie-for-monix","content":"EffectConstructorConsoleEffectCanCatchCanHandleErrorFromFutureOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Monix","url":"docs/monix/monix#all-in-one-example","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix.ConsoleEffectful._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ import effectie.monix.OptionTSupport._ import effectie.monix._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".asRight[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).value } } import monix.execution.Scheduler.Implicits.global println(Something[Task].foo(1).runSyncUnsafe()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[Task].bar(2.some).runSyncUnsafe()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[Task].bar(none[String]).runSyncUnsafe()) // None println(Something[Task].baz(2.asRight[String]).runSyncUnsafe()) // b: 2 / BLAH: blah blah // x: 4 // Right(4) println(Something[Task].baz(\"ERROR!!!\".asLeft[Int]).runSyncUnsafe()) // Left(ERROR!!!) Copy "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"docs/monix/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport","url":"docs/monix/optiont-support#optiontsupport","content":"import cats._ import cats.syntax.all._ import effectie.monix.Effectful._ import effectie.monix._ import effectie.monix.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).value } } import monix.eval._ import monix.execution.Scheduler.Implicits.global Something[Task].foo(1).runSyncUnsafe() // res1: Option[Int] = Some(value = 111) Something[Task].foo(10).runSyncUnsafe() // res2: Option[Int] = Some(value = 120) Something[Task].bar(1.some).runSyncUnsafe() // res3: Option[Int] = Some(value = 1000) Something[Task].bar(none[Int]).runSyncUnsafe() // res4: Option[Int] = None Copy "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"docs/monix/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: => F[Either[A, B]])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } Copy "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use","content":"TaskFutureId import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatal( Task(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: Task[Either[Throwable, Nothing]] = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.monix.CanCatch$$anon$1$$Lambda$11212/0x000000010362c840@113b5525, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // mdoc.internal.cli.MainOps$.process(MainOps.scala:269), // mdoc.Main$.process(Main.scala:26), // mdoc.Main$.process(Main.scala:21), // mdoc.Main$.main(Main.scala:16), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App6$$anonfun$doSomething$1.apply(can-catch.md:120), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App6$.doSomething(can-catch.md:123), // repl.MdocSession$App6$.<clinit>(can-catch.md:126), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](-101) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App12$$anonfun$doSomething$7.apply(can-catch.md:323), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App12$.doSomething(can-catch.md:326), // repl.MdocSession$App12$.<clinit>(can-catch.md:329), // repl.MdocSession$App10$.<clinit>(can-catch.md:280), // repl.MdocSession$App8$.<clinit>(can-catch.md:223), // repl.MdocSession$App6$.<clinit>(can-catch.md:143), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:18... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-1","content":"TaskFutureId import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatalEither( Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: Task[Either[Throwable, Int]] = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.monix.CanCatch$$anon$1$$Lambda$11212/0x000000010362c840@5084272d, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-1","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App24$$anonfun$doSomething$13.apply(can-catch.md:609), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // repl.MdocSession$App24$.doSomething(can-catch.md:612), // repl.MdocSession$App24$.<clinit>(can-catch.md:615), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // repl.MdocSession$App12$.<clinit>(can-catch.md:346), // repl.MdocSession$App10$.<clinit>(can-catch.md:280), // repl.MdocSession$App8$.<clinit>(can-catch.md:223), // repl.MdocSession$App6$.<clinit>(can-catch.md:143), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-1","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App30$$anonfun$doSomething$19.apply(can-catch.md:844), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // repl.MdocSession$App30$.doSomething(can-catch.md:847), // repl.MdocSession$App30$.<clinit>(can-catch.md:850), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // repl.MdocSession$App12$.<clinit>(can-catch.md:346), // repl.MdocSession$App10$.<clinit>(can-catch.md:280), // repl.MdocSession$App8$.<clinit>(can-catch.md:223), // repl.MdocSession$App6$.<clinit>(can-catch.md:143), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-2","content":"TaskFutureId import cats.data.EitherT import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatalEitherT( EitherT(Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[Task, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.monix.CanCatch$$anon$1$$Lambda$11212/0x000000010362c840@5fe1981a, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // ... import monix.execution.Scheduler.Implicits.global fa.value.runSyncUnsafe() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-2","content":"TaskFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@10a9458a, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.monix.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:22), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // effectie.monix.CanCatch.catchNonFatalEitherT(CanCatch.scala:22), // effectie.monix.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.monix.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:28), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-2","content":"TaskFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.EitherTSupport._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@347a1b1f, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.monix.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:22), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // effectie.monix.CanCatch.catchNonFatalEitherT(CanCatch.scala:22), // effectie.monix.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.monix.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:28), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-3","content":"TaskFutureId import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatal( Task(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: Task[Either[Throwable, Nothing]] = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.monix.CanCatch$$anon$1$$Lambda$11212/0x000000010362c840@f1b29cb, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // mdoc.internal.cli.MainOps$.process(MainOps.scala:269), // mdoc.Main$.process(Main.scala:26), // mdoc.Main$.process(Main.scala:21), // mdoc.Main$.main(Main.scala:16), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-3","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App60$$anonfun$doSomething$37.apply(can-catch.md:1733), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.monix.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App60$.doSomething(can-catch.md:1736), // repl.MdocSession$App60$.<clinit>(can-catch.md:1739), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // repl.MdocSession$App54$.<clinit>(can-catch.md:1638), // repl.MdocSession$App52$.<clinit>(can-catch.md:1615), // repl.MdocSession$App50$.<clinit>(can-catch.md:1541), // repl.MdocSession$App48$.<clinit>(can-catch.md:1445), // repl.MdocSession$App46$.<clinit>(can-catch.md:1362), // repl.MdocSession$App44$.<clinit>(can-catch.md:1288), // repl.MdocSession$App42$.<clinit>(can-catch.md:1192), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-3","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](-101) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App66$$anonfun$doSomething$43.apply(can-catch.md:1946), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // effectie.monix.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App66$.doSomething(can-catch.md:1949), // repl.MdocSession$App66$.<clinit>(can-catch.md:1952), // repl.MdocSession$App64$.<clinit>(can-catch.md:1900), // repl.MdocSession$App62$.<clinit>(can-catch.md:1840), // repl.MdocSession$App60$.<clinit>(can-catch.md:1756), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // repl.MdocSession$App54$.<clinit>(can-catch.md:1638), // repl.MdocSession$App52$.<clinit>(can-catch.md:1615), // repl.MdocSession$App50$.<clinit>(can-catch.md:1541), // repl.MdocSession$App48$.<clinit>(can-catch.md:1445), // repl.MdocSession$App46$.<clinit>(can-catch.md:1362), // repl.MdocSession$App44$.<clinit>(can-catch.md:1288), // repl.MdocSession$App42$.<clinit>(can-catch.md:1192), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-4","content":"TaskFutureId import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatalEither( Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: Task[Either[Throwable, Int]] = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.monix.CanCatch$$anon$1$$Lambda$11212/0x000000010362c840@6e521d76, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165), // scala.collection.immutable.List.foldLeft(List.scala:79), // mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:155), // mdoc.internal.cli.MainOps.run(MainOps.scala:177), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-4","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App78$$anonfun$doSomething$49.apply(can-catch.md:2241), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // effectie.monix.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App78$.doSomething(can-catch.md:2244), // repl.MdocSession$App78$.<clinit>(can-catch.md:2247), // repl.MdocSession$App76$.<clinit>(can-catch.md:2184), // repl.MdocSession$App74$.<clinit>(can-catch.md:2167), // repl.MdocSession$App72$.<clinit>(can-catch.md:2135), // repl.MdocSession$App70$.<clinit>(can-catch.md:2112), // repl.MdocSession$App68$.<clinit>(can-catch.md:2052), // repl.MdocSession$App66$.<clinit>(can-catch.md:1969), // repl.MdocSession$App64$.<clinit>(can-catch.md:1900), // repl.MdocSession$App62$.<clinit>(can-catch.md:1840), // repl.MdocSession$App60$.<clinit>(can-catch.md:1756), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // repl.MdocSession$App54$.<clinit>(can-catch.md:1638), // repl.MdocSession$App52$.<clinit>(can-catch.md:1615), // repl.MdocSession$App50$.<clinit>(can-catch.md:1541), // repl.MdocSession$App48$.<clinit>(can-catch.md:1445), // repl.MdocSession$App46$.<clinit>(can-catch.md:1362), // repl.MdocSession$App44$.<clinit>(can-catch.md:1288), // repl.MdocSession$App42$.<clinit>(can-catch.md:1192), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-4","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App84$$anonfun$doSomething$55.apply(can-catch.md:2485), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // effectie.monix.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App84$.doSomething(can-catch.md:2488), // repl.MdocSession$App84$.<clinit>(can-catch.md:2491), // repl.MdocSession$App82$.<clinit>(can-catch.md:2428), // repl.MdocSession$App80$.<clinit>(can-catch.md:2357), // repl.MdocSession$App78$.<clinit>(can-catch.md:2264), // repl.MdocSession$App76$.<clinit>(can-catch.md:2184), // repl.MdocSession$App74$.<clinit>(can-catch.md:2167), // repl.MdocSession$App72$.<clinit>(can-catch.md:2135), // repl.MdocSession$App70$.<clinit>(can-catch.md:2112), // repl.MdocSession$App68$.<clinit>(can-catch.md:2052), // repl.MdocSession$App66$.<clinit>(can-catch.md:1969), // repl.MdocSession$App64$.<clinit>(can-catch.md:1900), // repl.MdocSession$App62$.<clinit>(can-catch.md:1840), // repl.MdocSession$App60$.<clinit>(can-catch.md:1756), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // repl.MdocSession$App54$.<clinit>(can-catch.md:1638), // repl.MdocSession$App52$.<clinit>(can-catch.md:1615), // repl.MdocSession$App50$.<clinit>(can-catch.md:1541), // repl.MdocSession$App48$.<clinit>(can-catch.md:1445), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-5","content":"TaskFutureId import cats.data.EitherT import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatalEitherT[Task]( EitherT(Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[Task, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.monix.CanCatch$$anon$1$$Lambda$11212/0x000000010362c840@5d4dd8c6, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:28), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:185), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:152), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:52), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156), // scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169), // ... import monix.execution.Scheduler.Implicits.global fa.value.runSyncUnsafe() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-5","content":"TaskFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@79915d69, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.monix.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:22), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // effectie.monix.CanCatch.catchNonFatalEitherT(CanCatch.scala:22), // effectie.monix.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.monix.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:28), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-5","content":"TaskFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10991/0x0000000102bae840@21b12d9, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.monix.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:22), // effectie.monix.CanCatch$$anon$1.catchNonFatal(CanCatch.scala:32), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:37), // effectie.monix.CanCatch$$anon$1.catchNonFatalEither(CanCatch.scala:28), // effectie.monix.CanCatch.catchNonFatalEitherT(CanCatch.scala:22), // effectie.monix.CanCatch.catchNonFatalEitherT$(CanCatch.scala:19), // effectie.monix.CanCatch$$anon$1.catchNonFatalEitherT(CanCatch.scala:28), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"docs/scalaz-effect/can-catch","content":"","keywords":""},{"title":"CanCatch","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEither[A, B](fab: => F[A \\/ B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } Copy "},{"title":"CanCatch.catchNonFatal","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use","content":"IOFutureId import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[scalaz.\\/[Throwable, Nothing]] = scalaz.effect.IO$$anon$7@5ee7e73d fa.unsafePerformIO() // res1: scalaz.\\/[Throwable, Nothing] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@2662508c val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@35294466 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"CanCatch.catchNonFatalEither","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[A \\/ B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-1","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@8fc6ba7 fa.unsafePerformIO() // res19: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-1","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@47a56298 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-1","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@3aef9256 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-2","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@32c8fcb0 // ) fa.run.unsafePerformIO() // res37: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-2","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@7f7cb4a7 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-2","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@1186cdac val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-3","content":"IOFutureId import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatal( IO((throw new RuntimeException(\"Something's wrong!\")): Int) )(identity) // fa: IO[scalaz.\\/[Throwable, Int]] = scalaz.effect.IO$$anon$7@55f283e4 fa.unsafePerformIO() // res55: scalaz.\\/[Throwable, Int] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-3","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@1bd0f47 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-3","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@24164093 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"Catching.catchNonFatalEither","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[A \\/ B] and returns F[A \\/ B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-4","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@58c45496 fa.unsafePerformIO() // res73: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-4","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@2ec082b5 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-4","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@40ea7553 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching.catchNonFatalEitherT","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-5","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@7d01b15c // ) fa.run.unsafePerformIO() // res91: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-5","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@712ca671 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-5","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: EffectConstructor: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@7efcced6 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect","type":1,"pageTitle":"ConsoleEffect","url":"docs/scalaz-effect/console-effect#consoleeffect","content":"import scalaz._ import Scalaz._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"ConsoleEffectful","type":1,"pageTitle":"ConsoleEffect","url":"docs/scalaz-effect/console-effect#consoleeffectful","content":"import scalaz._ import Scalaz._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"EffectConstructor","type":0,"sectionRef":"#","url":"docs/scalaz-effect/effect-constructor","content":"","keywords":""},{"title":"EffectConstructor","type":1,"pageTitle":"EffectConstructor","url":"docs/scalaz-effect/effect-constructor#effectconstructor","content":"If you use Scalaz Effect and write tagless final code, and look for a generic way to construct F[A], EffectConstructor can help you. import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = EffectConstructor[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@7e27176 get1.unsafePerformIO() // res1: Int = 1 Copy If you feel it's too cumbersome to repeat EffectConstructor[F].effectOf(), consider using Effectful "},{"title":"Effectful","type":1,"pageTitle":"EffectConstructor","url":"docs/scalaz-effect/effect-constructor#effectful","content":"If you're sick of repeating EffectConstructor[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.scalaz.Effectful._ import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more EffectConstructor[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@7d5fd953 get1.unsafePerformIO() // res3: Int = 1 Copy "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"docs/scalaz-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport","type":1,"pageTitle":"EitherTSupport","url":"docs/scalaz-effect/eithert-support#eithertsupport","content":"import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[String \\/ Int] def bar(a: String \\/ Int): F[String \\/ Int] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[String \\/ Int] = (for { x <- eitherTRightPure(a) // == EitherT(pureOf(a).map(_.right[String])) y <- eitherTRight(x + 10) // == EitherT(effectOf(x + 10).map(_.right[String])) y2 <- if (y > 100) eitherTLeft[Int](\"Error - Bigger than 100\") else eitherTRightPure[String](y) //  if (y > 100) // EitherT(effectOf(\"Error - Bigger than 100\").map(_.left[Int])) // else // EitherT(pureOf(y).map(_.right[String])) z <- eitherTRightF[String](effectOf(y2 + 100)) // == EitherT(effectOf(y + 100).map(_.right)) } yield z).run def bar(a: String \\/ Int): F[String \\/ Int] = (for { x <- eitherTOfPure(a) // == EitherT(pureOf(a: String \\/ Int)) y <- eitherTOf((x + 999).right[String]) // == EitherT(effectOf((x + 999).right[String])) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: String \\/ Int = \\/-(b = 111) Something[IO].foo(10).unsafePerformIO() // res2: String \\/ Int = \\/-(b = 120) Something[IO].bar(1.right[String]).unsafePerformIO() // res3: String \\/ Int = \\/-(b = 1000) Something[IO].bar(\"No number\".left[Int]).unsafePerformIO() // res4: String \\/ Int = -\\/(a = \"No number\") Copy "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"docs/scalaz-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport","type":1,"pageTitle":"OptionTSupport","url":"docs/scalaz-effect/optiont-support#optiontsupport","content":"import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- optionTSomePure(a) // == OptionT.liftF(pureOf(a)) y <- optionTSome(x + 10) // == OptionT.liftF(effectOf(x + 10)) z <- optionTSomeF(effectOf(y + 100)) // == OptionT.lieftF(effectOf(y + 100)) } yield z).run def bar(a: Option[Int]): F[Option[Int]] = (for { x <- optionTOfPure(a) // == OptionT(pureOf(a: Option[Int])) y <- optionTOf((x + 999).some) // == OptionT(effectOf((x + 999).some)) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafePerformIO() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafePerformIO() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafePerformIO() // res4: Option[Int] = None Copy "},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/scalaz-effect","content":"","keywords":""},{"title":"Effectie for Scalaz Effect","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#effectie-for-scalaz-effect","content":"EffectConstructorConsoleEffectOptionTSupportEitherTSupport "},{"title":"All in One Example","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#all-in-one-example","content":"import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: A \\/ B): F[A \\/ B] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: EffectConstructor: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: EffectConstructor: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { a <- optionTOfPure(a) blah <- optionTOfPure(\"blah blah\".some) _ <- optionTSome(println(s\"a: $a / BLAH: $blah\")) x <- optionTSomeF(effectOf(a |+| a)) _ <- optionTSomeF(putStrLn(s\"x: $x\")) } yield x).run override def baz[A, B: Semigroup](ab: A \\/ B): F[A \\/ B] = (for { b <- eitherTOf(ab) blah <- eitherTOfPure(\"blah blah\".right[A]) _ <- eitherTRight(println(s\"b: $b / BLAH: $blah\")) x <- eitherTRightF(effectOf(b |+| b)) _ <- eitherTRightF[A](putStrLn(s\"x: $x\")) } yield x).run } } println(Something[IO].foo(1).unsafePerformIO()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafePerformIO()) // a: 2 / BLAH: blah blah // x: 4 // Some(4) println(Something[IO].bar(none[String]).unsafePerformIO()) // None println(Something[IO].baz(2.right[String]).unsafePerformIO()) // b: 2 / BLAH: blah blah // x: 4 // \\/-(4) println(Something[IO].baz(\"ERROR!!!\".left[Int]).unsafePerformIO()) // -\\/(ERROR!!!) Copy "}]